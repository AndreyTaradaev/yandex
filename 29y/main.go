package main

/*
Около Петиного университета недавно открылось новое кафе, в котором действует следующая система скидок:
 при каждой покупке более чем на 100 рублей покупатель получает купон,
  дающий право на один бесплатный обед (при покупке на сумму 100 рублей и меньше такой купон покупатель не получает).

Однажды Пете на глаза попался прейскурант на ближайшие N дней. Внимательно его изучив, он решил, что будет обедать
в этом кафе все N дней, причем каждый день он будет покупать в кафе ровно один обед. Однако стипендия у Пети небольшая,
и поэтому он хочет по максимуму использовать предоставляемую систему скидок так, чтобы его суммарные затраты были
 минимальны. Требуется найти минимально возможную суммарную стоимость обедов и номера дней, в которые Пете следует
  воспользоваться купонами.
Формат ввода

В первой строке входного файла записано целое число N (0 ≤ N ≤ 100). В каждой из последующих N строк записано одно
 целое число, обозначающее стоимость обеда в рублях на соответствующий день. Стоимость — неотрицательное целое число,
  не превосходящее 300.

Формат вывода

В первой строке выдайте минимальную возможную суммарную стоимость обедов. Во второй строке выдайте два числа K1 и K2
— количество купонов, которые останутся неиспользованными у Пети после этих N дней и количество использованных им купонов
соответственно.

В последующих K2 строках выдайте в возрастающем порядке номера дней, когда Пете следует воспользоваться купонами.
Если существует несколько решений с минимальной суммарной стоимостью, то выдайте то из них, в котором значение K1
 максимально (на случай, если Петя когда-нибудь ещё решит заглянуть в это кафе). Если таких решений несколько, выведите
  любое из них.

*/

import (
	"bufio"
	"fmt"
	"os"
	//	"sort"
)

func min(x, y int) int {

	if x > y {
		return y
	}
	return x
}

func main() {
	//var command string
	var N int // количество гвоздиков
	file, err := os.Open("input.txt")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer file.Close()
	rd := bufio.NewReader(file) // create reader
	_, err = fmt.Fscan(rd, &N)  //   command
	if err != nil {
		fmt.Println(err)
		return
	}
	a := make([]int, N+1, N+1)

	for i := 1; i < N+1; i++ {
		var g int
		_, err = fmt.Fscan(rd, &g) //   command
		if err != nil {
			fmt.Println(err)
			return
		}
		a[i] = g
	}
	dp := make([][]int, N+1, N+1)
	for i := 0; i < len(dp); i++ {
		dp[i] = make([]int, N+1, N+1)
	}

	for i := 1; i < N+1; i++ {
	dp[0][i] = 10000		
	}

	
	for i := 1; i < N+1; i++ {
		for j := 1; j < N; j++ {

			if a[i] <= 100 {
				dp[i][j] = min(dp[i-1][j]+a[i], dp[i-1][j+1])
			} else {
				dp[i][j] = min(dp[i-1][j-1]+a[i], dp[i-1][j+1])
			}
		}

	}

	fmt.Println(a)
	for _, v := range dp {
		fmt.Println(v)
	}	
}
