package main

/*
Около Петиного университета недавно открылось новое кафе, в котором действует следующая система скидок:
 при каждой покупке более чем на 100 рублей покупатель получает купон,
  дающий право на один бесплатный обед (при покупке на сумму 100 рублей и меньше такой купон покупатель не получает).

Однажды Пете на глаза попался прейскурант на ближайшие N дней. Внимательно его изучив, он решил, что будет обедать
в этом кафе все N дней, причем каждый день он будет покупать в кафе ровно один обед. Однако стипендия у Пети небольшая,
и поэтому он хочет по максимуму использовать предоставляемую систему скидок так, чтобы его суммарные затраты были
 минимальны. Требуется найти минимально возможную суммарную стоимость обедов и номера дней, в которые Пете следует
  воспользоваться купонами.
Формат ввода

В первой строке входного файла записано целое число N (0 ≤ N ≤ 100). В каждой из последующих N строк записано одно
 целое число, обозначающее стоимость обеда в рублях на соответствующий день. Стоимость — неотрицательное целое число,
  не превосходящее 300.

Формат вывода

В первой строке выдайте минимальную возможную суммарную стоимость обедов. Во второй строке выдайте два числа K1 и K2
— количество купонов, которые останутся неиспользованными у Пети после этих N дней и количество использованных им купонов
соответственно.

В последующих K2 строках выдайте в возрастающем порядке номера дней, когда Пете следует воспользоваться купонами.
Если существует несколько решений с минимальной суммарной стоимостью, то выдайте то из них, в котором значение K1
 максимально (на случай, если Петя когда-нибудь ещё решит заглянуть в это кафе). Если таких решений несколько, выведите
  любое из них.

*/

import (
	"bufio"
	"fmt"
	"os"
	//	"sort"
)

const inf int = 1000000

func min(x, y int) int {

	if x > y {
		return y
	}
	return x
}

func findmin(sl []int) (int, int) {
	if len(sl) == 0 {
		return -1, -1
	}
	var ind, val int = 0, sl[0]
	for i := 1; i < len(sl); i++ {
		if sl[i] <= val {
			val, ind = sl[i], i
		}
	}
	return ind, val
}

func main() {
	//var command string
	var N int // количество гвоздиков
	file, err := os.Open("input.txt")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer file.Close()
	rd := bufio.NewReader(file) // create reader
	_, err = fmt.Fscan(rd, &N)  //   command
	if err != nil {
		fmt.Println(err)
		return
	}
	a := make([]int, N+1, N+1) // массив цен на обеды по дням отсчет от 1 индекса(первый день)

	for i := 1; i < N+1; i++ {
		var g int
		_, err = fmt.Fscan(rd, &g) //   command
		if err != nil {
			fmt.Println(err)
			return
		}
		a[i] = g
	} // заполняем цены обедов

	// двумерный массив по строкам будут купоны по столбцам дни проходить надо по дням

	dp := make([][]int, N+1, N+1) //дни
	for i := 0; i < len(dp); i++ {
		dp[i] = make([]int, N+2, N+2) //купоны
	}
	// массив  дней когда использовались купоны

	for i := 0; i < len(dp); i++ {
		for j := 0; j < len(dp[i]); j++ {
			if j > i {
				dp[i][j] = inf
				continue
			}
			if j == 0 {
				if i == 0 {
					continue
				}
				if a[i] <= 100 {
					dp[i][j] = min(dp[i-1][j]+a[i], dp[i-1][j+1])
				} else {
					//если есть купон 	можем  использовать его
					if dp[i-1][j+1] != inf {
						dp[i][j] = min(dp[i-1][j]+a[i], dp[i-1][j+1])
					} else {
						dp[i][j] = inf
					}
				}
				continue
			} else {
				if a[i] <= 100 {
					dp[i][j] = min(dp[i-1][j]+a[i], dp[i-1][j+1])
				} else {
					dp[i][j] = min(dp[i-1][j-1]+a[i], dp[i-1][j+1])
				}
			}

		}
	}

	/*  fmt.Println(a)
	for _, v := range dp {
		fmt.Println(v)
	}  */
	ind, val := findmin(dp[len(dp)-1])
	fmt.Println(val)
	fmt.Print(ind, " ")

	sl := make([]int, 0, 0)

	for i := len(dp) - 1; i > 0; i-- {
		if val == dp[i-1][ind]+a[i] {
			val = dp[i-1][ind]
		} else if ind > 0 && val == dp[i-1][ind-1]+a[i] {
			val = dp[i-1][ind-1]
			ind-- //получил купон
		} else if val == dp[i-1][ind+1] { //был использован купон
			sl = append(sl, i)
			ind++
		}
	}
	fmt.Println(len(sl))

	for i := len(sl) - 1; i >= 0; i-- {
		fmt.Println(sl[i])
	}

}
