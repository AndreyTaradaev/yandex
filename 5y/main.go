package main

/*

На день рождения маленький Ипполит получил долгожданный подарок — набор дощечек с написанными на них буквами латинского алфавита. Теперь-то ему будет чем заняться долгими вечерами, тем более что мама обещала подарить ему в следующем году последовательность целых неотрицательных чисел, если он хорошо освоит этот набор. Ради такого богатства Ипполит готов на многое.

Прямо сейчас юный исследователь полностью поглощён изучением хорошести строк. Хорошестью строки называется количество позиций от 1 до L - 1 (где L — длина строки), таких, что следующая буква в строке является следующей по алфавиту. Например, хорошесть строки "abcdefghijklmnopqrstuvwxyz" равна 25, а строки "abdc" — только 1.

Ипполит размышляет над решением закономерно возникающей задачи: чему равна максимально возможная хорошесть строки, которую можно собрать, используя дощечки из данного набора? Вы-то и поможете ему с ней справиться.
Формат ввода

Первая строка ввода содержит единственное целое число N — количество различных букв в наборе (1 ≤ N ≤ 26). Обратите внимание: в наборе всегда используются N первых букв латинского алфавита.

Следующие N строк содержат целые положительные числа ci — количество букв соответствующего типа (1 ≤ ci ≤ 109). Таким образом, первое число означает количество букв "a", второе число задаёт количество букв "b" и так далее.
Формат вывода

Выведите единственное целое число — максимально возможную хорошесть строки, которую можно собрать из имеющихся дощечек.*/
import (
	"bufio"
	"fmt"
	"os"
)

func min(i, j int) int {
	if i > j {
		return j
	}
	return i
}

func main() {
	var N int                         //  количество различных букв в наборе (1 ≤ N ≤ 26).
	var sa []int = make([]int, 0, 30) //Следующие N строк содержат целые положительные числа ci — количество букв соответствующего типа (1 ≤ ci ≤ 109).
	//Таким образом, первое число означает количество букв "a", второе число задаёт количество букв "b" и так далее.

	//получаем данные
	file, err := os.Open("input1.txt") // open file
	if err != nil {
		fmt.Println(err)
		return
	}
	defer file.Close()

	rd := bufio.NewReader(file) // create reader

	_, err = fmt.Fscan(rd, &N) // scaN  count  letter
	if err != nil {
		fmt.Println(err)
		return
	}
	for i := 0; i < N; i++ {
		var k int
		_, err = fmt.Fscan(rd, &k)
		if err != nil {
			fmt.Println(err)
			return
		}
		sa = append(sa, k)
	}
	lengood := 0

	for i := 1; i < len(sa); i++ {
		lengood += min(sa[i-1], sa[i])
	}

	fmt.Println(lengood)

}
