Кто то решил вторую задачу быстрее, чем за n^2? У меня такое решение вылетает с TL:
Для каждой уникальной буквы пробегаюсь по строке и создаю список длин отрезков между одинаковыми буквами (например, для строки asdafgayaj и буквы a список будет [2, 2, 1]),
 а затем прохожу одним проходом по списку отрезков и ищу максимальную "красоту" строки.
Подскажите, можно ли быстрее )

Можно, через 2 указателя будет O(N)


Делаем внешний цикл по алфавиту, 
создаём переменную t = k, max = 0, count = 0, 
далее проходим по строке двумя указателями: 
изначально оба указывают на первый элемент, 
если следующий элемент строки равен рассматриваемому в цикле - двигаем правый указатель, и увеличиваем count,
 иначе тоже двигаем, но t уменьшаем на единицу, если вдруг t не хватило, 
то двигаем в право левый указатель, при этом если сдвигаем с элемента, который а цикле, то t увеличиваемн на единицу, 
двигаем пока t не станет равным единице 
и потом заново с правым указателем делаем всё то же, что и раньше, делаем так далее, каждый раз проверяя max < count


у меня также выходит, нужна ваша помощь. 
алгоритм начинается с подсчета количество вхождений каждого символа.
 храню в словаре. затем сортировка словаря по убываюнию значений. 
Внешний цикл проход по всем символам словаря. 
внутрений проход по строке. 
если текущий символ словаря совпадает с символом строки. 
то мы сдвигает правый указатель на 1 вперед и текущий счетчик символом инкрементируем, 
и затем проверка, что max < count. 
Если символы разные, то проверяю текущие кол-во замен, 
которое есть на данном шаге. и если кол-во больше 0, 
то сдвигаю правый указатель вперед и увел кол-во,
 и уменьшаю текущие кол-во замен на 1.  
иначе левый указатель сдвигаю на 1 вперед и кол-во уменьшаю на 1.


для тех кто не забрался с 2 задачей. надо учесть что делать, если элемент на который ссылается левый указатель не равен текущему элементу в словаре


Задача 3B 2 Красивая строка.
Не прохожу по времени восьмой тест. не на python не на pypy
Подскажите пожалуйста как оптимизировать?

Использую два указателя.


#include <bits/stdc++.h>
 
using namespace std;
 
using vi = vector<int>;
using ii = pair<int, int>;
 
int main() {
    int n, k;
    cin >> n >> k;
    
    string s;
    cin >> s;
    
    ii ans(-1, -1);
    
    map<char, int> counts;
    
    for (int leftIn = 0, rightOut = leftIn; leftIn < n; ++leftIn) {
        while (rightOut < n && counts[s[rightOut]] < k) {
            counts[s[rightOut]]++;
            ++rightOut;
        }
        
        int length = rightOut - leftIn;
        if (ans.first < length) {
            ans.first = length;
            ans.second = leftIn;
        }
        
        counts[s[leftIn]]--;
    }
    
    cout << ans.first << " " << ans.second + 1 << "\n";
 
    return 0;
}


#include <bits/stdc++.h> 
 
using namespace std; 
using ll = long long; 
 
const ll mod = 1e9 + 7; 
 
ll n, k; 
 
vector<short> arr; 
vector<ll> dp; 
 
ll getNum ( ll index ) { 
    if ( k == 1 || k == 2 ) return 0; 
    return index  >= 0 ? dp[index] :  0; 
} 
 
 
int main () { 
    cin >> n >> k; 
 
    arr.resize(n + 2); 
    dp.resize(n + 2);    
    // Считывание 
    for (ll i = 1; i < n + 1; i++) {  
         char c; 
         cin >> c; 
         arr[i] = c - 48; 
    } 
    // База 
    dp[0] = 1; 
    dp[1] = 1 - arr[1]; 
    dp[2] = arr[2] == 1 ? 0 : dp[1] + dp[0]; 
    // Динамика 
    for (ll i = 3; i < n + 1; i++) { 
        dp[i] = arr[i] == 1 ? 0 :  dp[i - 1] + dp[i - 2] + getNum(i - k) ; 
    } 
     
    cout << (dp[n] % mod); 
 
    return 0; 
}


#include <bits/stdc++.h>
#define s string
#define f for (i = 0; i < a; i++) 
using namespace std;
int a, i, d, z;
bool c(s a, s b) {
    d = a.size(), z = b.size();
    return d == z ? a < b : d < z;
}
main() {
    cin >> a;
    s A[a];
    f 
        cin >> A[i];
    sort(A, A+a, c);
    f
        cout << A[i] << '\n';
}
Задача 3B 2 Красивая строка.
Не прохожу по времени восьмой тест. не на python не на pypy
Подскажите пожалуйста как оптимизировать?

Использую два указателя.

Пока правый не дойдет до конца
    Внутри пока правый не дойдет до конца или не закончится лимит замен
После этого к левому добавляю единицу и правый возвращаю на левый + 1

Пытался пропускать проверенный интервал и делать левый = правый, но тогда неверный ответ, да и логика подсказывает что внутри отрезка могут быть нужные символы.

Или задача другим образом решается?

Пока правый не дойдет до конца
    Внутри пока правый не дойдет до конца или не закончится лимит замен
После этого к левому добавляю единицу и правый возвращаю на левый + 1

Пытался пропускать проверенный интервал и делать левый = правый, но тогда неверный ответ, да и логика подсказывает что внутри отрезка могут быть нужные символы.

Или задача другим образом решается?